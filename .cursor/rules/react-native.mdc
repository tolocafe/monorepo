---
description: React Native and Expo Best Practices
globs: ['src/**/*.tsx', 'src/**/*.ts']
alwaysApply: false
---

# Modern React Native & Expo Development Standards

## Core Architecture Principles

- Use functional components with TypeScript interfaces
- Prefer composition over inheritance
- Follow React best practices and hooks patterns
- Use Expo Router for file-based navigation
- Implement proper error boundaries
- Use strict TypeScript mode for type safety

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure files: exported component, subcomponents, helpers, static content, types
- Use the "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals; use concise syntax
- Use declarative JSX patterns

## TypeScript Best Practices

- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use const objects or maps instead
- Use functional components with TypeScript interfaces
- Implement strict null checks and proper error handling
- **Prefer inferred return types**: Let TypeScript infer function return types rather than explicitly annotating them. Only add explicit return types when the inference is incorrect, for public API documentation, or when the function is complex enough that explicit types improve readability
- Define proper prop types for components
- Use generic types for reusable components
- Leverage discriminated unions for complex state scenarios

## React Import Patterns

- **Never import React default**: JSX is available at runtime, no need for `import React from 'react'`
- **Import specific APIs**: Use `import { useState, useEffect } from 'react'` for hooks
- **Import React Native components**: Use `import { View, Text } from 'react-native'`
- **Import third-party APIs directly**: Import only what you need from each package
- **No default React import**: Modern React Native handles JSX transformation automatically

## React Compiler

- **React Compiler Enabled**: This project uses the React Compiler for automatic optimization
- **Automatic Memoization**: Components and values are automatically memoized by the compiler
- **Reduced Manual Optimization**: Less need for manual React.memo, useMemo, and useCallback
- **Rules of React**: Follow React's rules strictly - the compiler enforces them at build time
- **Pure Components**: Ensure components are pure and side-effect-free for optimal compilation
- **Hook Dependencies**: The compiler tracks dependencies automatically, but still use proper arrays
- **Build-Time Optimization**: Performance optimizations happen at compile time, not runtime

## Performance Optimization

- Minimize useState and useEffect; prefer context and reducers for state management
- React Compiler handles most memoization automatically, but React.memo() can still be useful for expensive components
- Use useMemo and useCallback sparingly - the compiler optimizes most cases automatically
- Avoid unnecessary re-renders with proper dependency arrays
- Use FlatList for long lists with proper optimization props
- Implement code splitting with React.lazy and Suspense
- Optimize images: use WebP format, include size data, implement lazy loading
- Use Expo's AppLoading and SplashScreen for optimized startup

## Safe Area Management

- Use SafeAreaProvider from react-native-safe-area-context globally
- Wrap top-level components with SafeAreaView for proper insets
- Use SafeAreaScrollView for scrollable content
- Avoid hardcoding padding/margins; use SafeAreaView and context hooks
- Handle notches, status bars, and screen insets properly on both platforms

## Navigation Best Practices

- Use Expo Router for file-based routing and navigation
- Implement proper deep linking and universal links
- Use typed navigation with proper route parameters
- Handle navigation state properly in components
- Implement proper back button handling
- Use navigation guards for protected routes

## State Management

- Use React Context and useReducer for global state
- Leverage TanStack Query for data fetching and caching
- Implement proper error states and loading states
- Use Zustand for complex state management when needed
- Handle optimistic updates appropriately
- Implement proper cache invalidation strategies

## Error Handling and Validation

- Use Zod for runtime validation and error handling
- Implement proper error logging with Sentry
- Handle errors at the beginning of functions
- Use early returns for error conditions
- Avoid deeply nested if statements
- Implement global error boundaries
- Provide user-friendly error messages
- Log errors with proper context

## Testing Standards

- Write unit tests using Jest and React Native Testing Library
- Implement integration tests for critical user flows
- Use snapshot testing for UI consistency
- Test accessibility features and screen readers
- Mock external dependencies properly
- Test error scenarios and edge cases
- Maintain high test coverage for critical paths

## Security Guidelines

- Sanitize user inputs to prevent XSS attacks
- Use react-native-encrypted-storage for sensitive data
- Ensure secure communication with HTTPS
- Implement proper authentication flows
- Validate all API responses
- Use environment variables for sensitive configuration
- Follow Expo's security guidelines

## Accessibility (a11y) Standards

- Use proper accessibility labels and hints
- Implement screen reader support
- Ensure proper focus management
- Use semantic elements appropriately
- Test with accessibility tools
- Support dynamic text sizing
- Implement proper color contrast
- Handle accessibility announcements

## Platform-Specific Considerations

- Test extensively on both iOS and Android
- Handle platform differences gracefully
- Use Platform.select() for platform-specific code
- Implement proper keyboard handling
- Handle different screen sizes and orientations
- Consider platform-specific UI patterns
- Test on different device types and OS versions

## Development Workflow

- Use Expo's managed workflow for streamlined development
- Implement proper environment configuration
- Use expo-constants for environment variables
- Handle device permissions gracefully
- Implement OTA updates with expo-updates
- Follow Expo's deployment best practices
- Use proper version management and release channels

## Code Organization

- Use feature-based folder structure
- Keep components focused and single-purpose
- Extract custom hooks for reusable logic
- Organize utilities and helpers appropriately
- Use barrel exports for clean imports
- Follow consistent naming conventions
- Implement proper file and folder naming patterns
